\input{header.tex}

\title{3 -- Private Key Encryption}

\newcommand*{\PrivKExpt}[2]{\operatorname{PrivK}_{#2}^{\textrm{#1}}}
\newcommand*{\PrivKOut}[2]{\operatorname{PrivKOut}_{#2}^{\textrm{#1}}}

\begin{document}

\maketitle
\initMinimal{}

\tableofcontents

\section{Computational Security}

\subsection{Definition of relaxations}

Unlike perfect security, we make 2 additional assumptions to make
secure encryption practical:
\begin{itemize}
\item Adversaries are \textbf{efficient} and only run for a feasible amount of time.
\item Adversaries have a \textbf{negligible} probability of success.
\end{itemize}

All encryption schemes are parametrized by a security parameter $n$.
$n$ is usually the key length.
The terms `efficient' and `negligible' are defined in terms of $n$.

\begin{definition}
An efficient adversary is a probabilistic polynomial-time (PPT) algorithm,
where the input is at least as large as the security parameter.
\end{definition}
\begin{definition}
Denote the set of all negligible functions of $n$ as $\operatorname{negl}(n)$, where
\[ \operatorname{negl}(n) = \bigcap_{k \in \mathbb{N}} o(n^{-k}) \]
\end{definition}

\begin{theorem}
\[ f \in \operatorname{negl}(n) \iff \forall p(x) \in \mathbb{R}[x],
\exists N \in \mathbb{N}, \forall n \ge N, f(n) < \frac{1}{p(n)} \]
\end{theorem}
\begin{theorem}
\[ f \in \operatorname{negl}(n) \implies (\forall p(x) \in \mathbb{R}[x], p(n)f(n) \in \operatorname{negl}(n)) \]
\end{theorem}

\subsection{[Draft] Necessity of the relaxations}

(TODO: Needs rigor)

\begin{itemize}
\item Powerful adversary can brute force the set of keys to break scheme with very high probability.
\item Normal adversary can guess key and break scheme with slightly higher probability than pure guess.
\end{itemize}

\section{Defining Computationally Secure Encryption}

\begin{itemize}
\item The key-generation algorithm \textsf{Gen} takes input $1^n$ and returns key $k$.
We assume (why?) that $|k| \ge n$.
\item The encryption algorithm \textsf{Enc} takes the key and message as input and outputs a ciphertext.
\item The decryption algorithm \textsf{Dec} takes the key and ciphertext as input and outputs a message.
\end{itemize}

\begin{definition}
The adversarial indistinguishability experiment $\PrivKExpt{eav}{A,\Pi}(n)$:
\begin{enumerate}
\item $A$ is given input $1^n$. It outputs 2 messages $m_0$ and $m_1$ with $|m_0| = |m_1|$.
\item $k \in \mathcal{K}$ is generated by running $\mathsf{Gen}(1^n)$.
$b$ is chosen uniformly randomly from $\{0, 1\}$.
$c = e_k(m)$, called the challenge ciphertext, is computed and given to $A$.
\item $A$ outputs a bit $b'$.
\item $\PrivKExpt{eav}{A,\Pi}(n) = \begin{cases}1 & \textrm{ if } b' = b \\ 0 & \textrm{ if } b' \neq b\end{cases}$.
\end{enumerate}
\end{definition}

Messages output by adversary are required to be of the same length
otherwise adversary can use ciphertext length to determine which message was encrypted.

\begin{definition}
Scheme $\Pi$ is EAV-secure iff for every PPT adversary $A$,
\[ \Pr\left[ \PrivKExpt{eav}{A,\Pi}(n) = 1\right] - \frac{1}{2}
\in \operatorname{negl}(n) \]
\end{definition}

\begin{definition}
Let $\PrivKExpt{eav}{A,\Pi}(n, b)$ be the experiment where the message chosen by the challenger
is fixed to be $m_b$ (instead of choosing uniformly randomly from $\{m_0, m_1\}$),
but the adversary doesn't know this.
Let $\PrivKOut{eav}{A,\Pi}(n, b)$ be the output $b'$ of the adversary.
\end{definition}

\begin{theorem}
$\Pi$ is secure iff for all PPT adversaries $A$,
\[ \left| \Pr\left[ \PrivKOut{eav}{A,\Pi}(n, 1) = 1 \right]
- \Pr\left[ \PrivKOut{eav}{A,\Pi}(n, 0) = 1 \right] \right| \in \operatorname{negl}(n) \]
\end{theorem}

\section{Pseudorandom Generators}

\begin{definition}
Let $l(n)$ be a polynomially-bounded function.
Let $G: \{0, 1\}^n \mapsto \{0, 1\}^{l(n)}$ be a deterministic polynomial-time algorithm.
$G$ is a pseudorandom generator (aka PRG) iff both these conditions hold:
\begin{itemize}
\item Expansion: $\forall n>1, l(n) > n$.
\item Pseudorandomness: For any PPT algorithm $D$,
\[ \left| \Pr_{s \in_R \{0, 1\}^n} [D(G(s))=1] - \Pr_{r \in_R \{0, 1\}^{l(n)}} [D(r)=1] \right|
\in \operatorname{negl}(n) \]
\end{itemize}
\end{definition}

A pseudorandom generator $G$ can be used to construct an encryption scheme $\Pi_G$:
\begin{itemize}
\item \textsf{Gen}: $k \in_R \mathcal{K}$.
\item $e_k(m) = m \oplus G(k)$.
\item $d_k(c) = c \oplus G(k)$.
\end{itemize}

\begin{theorem} $G$ is a PRG $\implies \Pi_G$ is EAV-secure. \end{theorem}

\section{Stronger notions of security}

\subsection{Multiple messages}

The multiple-message eavesdropping experiment $\PrivKExpt{mult}{A,\Pi}(n)$:
\begin{enumerate}
\item The adversary $A$ is given input $1^n$ and outputs
$M_0 = [m_{0,i}]_{i=1}^t$ and $M_1 = [m_{1,i}]_{i=1}^t$ where $\forall i, |m_{0,i}| = |m_{1,i}|$.
\item $k = \mathsf{Gen}(1^n)$, $b \in_R \{0, 1\}$.
\item $\forall i, c_i = e_k(m_{b,i})$. $C = [c_i]_{i=1}^n$.
\item $A$ is given $C$ and it outputs a bit $b'$.
\item $\PrivKExpt{mult}{A,\Pi}(n) = \begin{cases}1 & \textrm{ if } b' = b \\ 0 & \textrm{ if } b' \neq b\end{cases}$.
\end{enumerate}

\begin{definition}
$\Pi$ has indistinguishable multiple encryptions iff
\[ \Pr\left[\PrivKExpt{mult}{A,\Pi}(n) = 1\right] - \frac{1}{2} \in \operatorname{negl}(n) \]
\end{definition}

\begin{theorem}
Any stateless and deterministic encryption scheme has distinguishable multiple encryptions.
\end{theorem}
\begin{proof}
The adversary chooses message lists $M_0 = (m, m)$ and $M_1 = (m, m')$.
Then given $C = (c_1, c_2)$, it outputs $b' = (c_1 \neq c_2)$.
The adversary succeeds with probability 1.
\end{proof}

\section{Chosen-Plaintext Attack}

The chosen-plaintext attack experiment $\PrivKExpt{cpa}{A,\Pi}(n)$:
\begin{enumerate}
\item $k = \mathsf{Gen}(1^n)$.
\item $A$ is given input $1^n$ and oracle access to $e_k$ and outputs $(m_0, m_1)$ where $|m_0| = |m_1|$.
\item $b \in_R \{0, 1\}$. $c = e_k(m_b)$ is given to $A$.
\item $A$, which continues to have oracle access to $e_k$, outputs a bit $b'$.
\item $\PrivKExpt{cpa}{A,\Pi}(n) = \begin{cases}1 & \textrm{ if } b' = b \\ 0 & \textrm{ if } b' \neq b\end{cases}$.
\end{enumerate}

\begin{definition}
$\Pi$ is indistinguishable under chosen-plaintext attack iff
\[ \Pr\left[\PrivKExpt{cpa}{A,\Pi}(n)\right] - \frac{1}{2} \in \operatorname{negl}(n) \]
\end{definition}

\begin{definition}
The LR-oracle $\operatorname{LR}_{k,b}$ is a function where
$\operatorname{LR}_{k,b}(m_0, m_1) = e_k(m_b)$.
\end{definition}

The LR-oracle experiment $\PrivKExpt{lr-cpa}{A,\Pi}(n)$:
\begin{enumerate}
\item $k = \mathsf{Gen}(1^n)$. $b \in_R \{0, 1\}$.
\item $A$ is given input $1^n$ and oracle access to $\operatorname{LR}_{k,b}$.
\item $A$ outputs a bit $b'$.
\item $\PrivKExpt{lr-cpa}{A,\Pi}(n) = \begin{cases}1 & \textrm{ if } b' = b \\ 0 & \textrm{ if } b' \neq b\end{cases}$.
\end{enumerate}

\begin{definition}
$\Pi$ has indistinguishable multiple encryptions under chosen-plaintext attack if
\[ \Pr\left[\PrivKExpt{lr-cpa}{A,\Pi}(n)\right] - \frac{1}{2} \in \operatorname{negl}(n) \]
\end{definition}

\begin{theorem} $\Pi$ is CPA-secure iff it is multi-CPA-secure. \end{theorem}
\begin{proof} (Proof will appear in a later chapter) \end{proof}

\section{Pseudorandom Functions}

\begin{definition}
Let $|\mathcal{M}|, |\mathcal{K}|, |\mathcal{C}| \in \operatorname{poly}(n)$.
Let $\mathsf{Func}_{\mathcal{M}, \mathcal{C}}$ be the family of all functions from $\mathcal{M}$ to $\mathcal{C}$.
Let $F = \{F_k: k \in \mathcal{K} \} \subseteq \mathsf{Func}_{\mathcal{M}, \mathcal{C}}$ be a function family.
$F$ is pseudorandom iff for every PPT distinguisher $D$,
\[ \left| \Pr_{k \in_R \mathcal{K}}\left[ D^{F_k}(1^n) = 1 \right]
- \Pr_{f \in_R \mathsf{Func}_{\mathcal{M}, \mathcal{C}}}\left[ D^f(1^n) = 1 \right] \right|
\in \operatorname{negl}(n) \]
\end{definition}

\begin{example} $F_k(x) = x \oplus k$ is not pseudorandom. \end{example}

\begin{definition} A function family $F$ is efficient iff $\forall f \in F$,
$f$ can be computed in polynomial time. \end{definition}

\begin{definition}
Let $|\mathcal{M}|, |\mathcal{K}| \in \operatorname{poly}(n)$.
Let $\mathsf{Perm}_{\mathcal{M}}$ be the family of all permutations of $\mathcal{M}$.
Let $F = \{F_k: k \in \mathcal{K} \} \subseteq \mathsf{Perm}_{\mathcal{M}}$ be a permutation family.
$F$ is pseudorandom iff for every PPT distinguisher $D$,
\[ \left| \Pr_{k \in_R \mathcal{K}}\left[ D^{F_k}(1^n) = 1 \right]
- \Pr_{f \in_R \mathsf{Perm}_{\mathcal{M}}}\left[ D^f(1^n) = 1 \right] \right|
\in \operatorname{negl}(n) \]
$F$ is strongly pseudorandom iff for every PPT distinguisher $D$,
\[ \left| \Pr_{k \in_R \mathcal{K}}\left[ D^{F_k,F_k^{-1}}(1^n) = 1 \right]
- \Pr_{f \in_R \mathsf{Perm}_{\mathcal{M}}}\left[ D^{f,f^{-1}}(1^n) = 1 \right] \right|
\in \operatorname{negl}(n) \]
\end{definition}

A pseudorandom permutation is also called a block cipher.

\begin{definition} A permutation family $F$ is efficient iff $\forall f \in F$,
$f$ and $f^{-1}$ can be computed in polynomial time. \end{definition}

\begin{theorem}
If $F = \{F_k: k \in \mathcal{K}\} \subseteq \mathsf{Perm}_{\mathcal{M}}$
is a pseudorandom permutation and $|\mathcal{M}| \ge |\mathcal{K}|$,
then $F$ is also a pseudorandom function.
\end{theorem}
\begin{proof} (TODO: Add proof) \end{proof}

\begin{theorem}
Let $F$ be a pseudorandom function. Let $G(s) = \operatorname{concat}_{i=1}^l F_s(i)$.
Then $G$ is a pseudorandom generator.
\end{theorem}

\begin{theorem}
A pseudorandom generator with expansion $l(n)$ can be used to construct a pseudorandom function
with input and output size $O(\log n)$.
\end{theorem}

\begin{theorem}
Let $F$ be a pseudorandom function family. Let $\Pi(n)$ be this scheme:
\begin{itemize}
\item $\mathsf{Gen}: k \in_R \{0, 1\}^n$.
\item $e_k(m) = (r, F_k(r) \oplus m)$, where $r \in_R \{0, 1\}^n$.
\item $d_k((r, c)) = F_k(r) \oplus c$.
\end{itemize}
Then $\Pi(n)$ is LR-CPA-secure.
\end{theorem}

\section{CTR mode of operation}

`Mode of operation' is a way of encrypting messages of variable lengths
using a fixed-length block cipher.

Specification of CTR mode of operation, which uses a pseudorandom function family $F$:
\begin{itemize}
\item \textsf{Gen}: $k \in_R \{0, 1\}^n$.
\item $e_k([m_i]_{i=1}^l) = [\mathrm{IV}] + [F_k(c+i) \oplus m_i]_{i=1}^l$,
where $\mathrm{IV} \in_R \{0, 1\}^n$ is called the initialization vector.
\item $d_k([\mathrm{IV}] + [m_i]_{i=1}^l) = [F_k(c+i) \oplus c_i]_{i=1}^l$
\end{itemize}

\begin{theorem} The CTR mode of operation is LR-CPA-secure. \end{theorem}

\end{document}
